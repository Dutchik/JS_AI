<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>JSè‡ªä½œãƒ»å­¦ç¿’å‹ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 16px;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    .container {
      display: flex;
      gap: 16px;
    }
    .left, .right {
      flex: 1;
      min-width: 0;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      background: #222;
      color: #eee;
      border: 1px solid #444;
      padding: 8px;
      resize: vertical;
    }
    button {
      margin-top: 8px;
      padding: 6px 10px;
      border: 1px solid #555;
      background: #222;
      color: #eee;
      cursor: pointer;
    }
    button:hover {
      background: #333;
    }
    #chatLog {
      border: 1px solid #444;
      background: #000;
      padding: 8px;
      height: 400px;
      overflow-y: auto;
      font-size: 14px;
      white-space: pre-wrap;
    }
    .msg-user {
      color: #8fd1ff;
      margin-bottom: 4px;
    }
    .msg-bot {
      color: #ffd47f;
      margin-bottom: 8px;
    }
    .msg-note {
      color: #9acd32;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .small {
      font-size: 12px;
      color: #aaa;
    }
    #stats {
      margin-top: 8px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>
<body>
  <h1>JSè‡ªä½œãƒ»å­¦ç¿’å‹ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆï¼ˆäººåŠ›ã§é›ãˆã‚‹å¥´ï¼‰</h1>
  <div class="small">
    ãƒ»ä¼šè©±ã™ã‚‹ã»ã©å­¦ç¿’ã€‚<br>
    ãƒ»Botã®è¿”ç­”ãŒã‚ºãƒ¬ã¦ãŸã‚‰ä¸‹ã§ä¿®æ­£ã—ã¦ã€Œä¿®æ­£ã‚’å­¦ç¿’ã•ã›ã‚‹ã€ã€‚<br>
    ãƒ»ã€Œå¤ã„ä¼šè©±ã‚’åœ§ç¸®ã€ã§ã€éå»ãƒ­ã‚°ã‚’å˜èªé »åº¦ã«ç•³ã¿è¾¼ã¿ã¤ã¤æ•´ç†ã€‚
  </div>

  <div class="container" style="margin-top:12px;">
    <div class="left">
      <div>
        <label for="userInput">ã‚ãªãŸã®å…¥åŠ›:</label><br>
        <textarea id="userInput" rows="3"></textarea><br>
        <button id="sendBtn">é€ä¿¡</button>
      </div>

      <div style="margin-top:16px;">
        <label for="correctionInput">ç›´ã—ãŸã„Botã®è¿”ç­”ãŒã‚ã‚Œã°ä¿®æ­£ã—ã¦å…¥åŠ›:</label><br>
        <textarea id="correctionInput" rows="3" placeholder="ã“ã“ã«æ­£ã—ã„è¿”ç­”ã‚’æ›¸ã„ã¦ã€Œä¿®æ­£ã‚’å­¦ç¿’ã•ã›ã‚‹ã€ã‚’æŠ¼ã™"></textarea><br>
        <button id="applyCorrectionBtn">ä¿®æ­£ã‚’å­¦ç¿’ã•ã›ã‚‹ï¼ˆç›´å‰ã®Botç™ºè¨€ã«é©ç”¨ï¼‰</button>
      </div>

      <div style="margin-top:16px;">
        <button id="compressBtn">å¤ã„ä¼šè©±ã‚’åœ§ç¸®ï¼ˆçµ±è¨ˆã«ç•³ã¿è¾¼ã‚“ã§æ•´ç†ï¼‰</button>
        <div id="stats"></div>
      </div>
    </div>

    <div class="right">
      <div>å¯¾è©±ãƒ­ã‚°:</div>
      <div id="chatLog"></div>
    </div>
  </div>

  <script>
    class Brain {
      constructor() {
        this.memory = [];          // ç›´è¿‘ã®ä¼šè©±ãƒ­ã‚°ï¼ˆè©³ç´°ï¼‰
        this.archive = {           // å¤ã„ä¼šè©±ã®çµ±è¨ˆ
          tokenFreq: {},           // å˜èª -> ç´¯ç©é »åº¦
          totalUtterances: 0       // åœ§ç¸®ã«å›ã—ãŸç™ºè©±æ•°
        };
        this.nextId = 1;           // ä¼šè©±IDæ¡ç•ª
      }

      // ãƒ†ã‚­ã‚¹ãƒˆ â†’ ãƒˆãƒ¼ã‚¯ãƒ³é…åˆ—ï¼ˆã‹ãªã‚Šé›‘ãªåˆ†ã‹ã¡æ›¸ãï¼‰
      tokenize(text) {
        return text
          .toLowerCase()
          .replace(/[^a-z0-9ã-ã‚“ã‚¡-ãƒ³ä¸€-é¾ ãƒ¼\s]/g, " ")
          .split(/\s+/)
          .filter(t => t.length > 0);
      }

      // ãƒ†ã‚­ã‚¹ãƒˆ â†’ å˜èªé »åº¦ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆç–ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰
      textToVector(text) {
        const tokens = this.tokenize(text);
        const vec = {};
        for (const t of tokens) {
          vec[t] = (vec[t] || 0) + 1;
        }
        return vec;
      }

      // ã‚³ã‚µã‚¤ãƒ³é¡ä¼¼åº¦ï¼ˆç–ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ï¼‰
      cosineSimilarity(a, b) {
        let dot = 0;
        let na = 0;
        let nb = 0;

        for (const k in a) {
          const x = a[k];
          na += x * x;
          if (k in b) {
            dot += x * b[k];
          }
        }
        for (const k in b) {
          const y = b[k];
          nb += y * y;
        }
        if (na === 0 || nb === 0) return 0;
        return dot / (Math.sqrt(na) * Math.sqrt(nb));
      }

      // 1å¾€å¾©ã®ä¼šè©±ã‚’è¨˜æ†¶ã—ã€IDã‚’è¿”ã™
      learn(userText, botText) {
        const vec = this.textToVector(userText);
        const item = {
          id: this.nextId++,
          user: userText,
          bot: botText,
          corrected: false,
          ts: Date.now(),
          vec
        };
        this.memory.push(item);
        this.save();
        return item.id;
      }

      // äººé–“ã«ã‚ˆã‚‹ã€Œã“ã®è¿”ç­”ãŒæ­£è§£ã ã€ä¿®æ­£
      learnCorrection(id, correctedBotText) {
        const item = this.memory.find(m => m.id === id);
        if (!item) return;
        item.bot = correctedBotText;
        item.corrected = true;
        item.ts = Date.now();  // æ›´æ–°æ™‚åˆ»ã¨ã—ã¦ä¸Šæ›¸ã
        this.save();
      }

      // ä¼¼ã¦ã„ã‚‹éå»ç™ºè©±ã‚’æ¢ã™ï¼ˆä¿®æ­£æ¸ˆã¿ãƒ­ã‚°ã‚’å°‘ã—å„ªé‡ï¼‰
      findNearestReply(userText) {
        if (this.memory.length === 0) return null;
        const v = this.textToVector(userText);
        let best = null;
        let bestScore = -1;
        for (const m of this.memory) {
          const sim = this.cosineSimilarity(v, m.vec);
          let score = sim;
          if (m.corrected) score += 0.1;  // äººé–“ãŒç›´ã—ãŸã‚‚ã®ã¯å„ªå…ˆ
          if (score > bestScore) {
            bestScore = score;
            best = m;
          }
        }
        if (bestScore < 0.2) return null; // ä¼¼ã¦ãªã•ã™ããŸã‚‰ä¸æ¡ç”¨
        return best.bot;
      }

      // è¿”ç­”ãƒ­ã‚¸ãƒƒã‚¯
      reply(userText) {
        // 1. ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒ«ï¼ˆä¾‹ï¼‰
        if (userText.includes("ç–²ã‚ŒãŸ")) {
          return "ç–²ã‚ŒãŸã®ã¯åˆ†ã‹ã‚‹ãŒã€æ™‚é–“ã®æ–¹ãŒãŠå‰ã«æ–‡å¥è¨€ã„ãŸã„ã¨æ€ã£ã¦ã‚‹ãã€‚";
        }
        if (userText.includes("ã‚„ã‚‹æ°—")) {
          return "ã‚„ã‚‹æ°—ã¯å¾…ã¤ã‚‚ã®ã˜ã‚ƒãªãã¦ã€ä½œæ¥­ã‚’å§‹ã‚ãŸå‰¯ç”£ç‰©ã ã€‚ã•ã£ã•ã¨1è¡Œã‚„ã‚Œã€‚";
        }

        // 2. é¡ä¼¼ã—ãŸéå»ä¼šè©±ã‹ã‚‰å€Ÿã‚Šã‚‹
        const learned = this.findNearestReply(userText);
        if (learned) return learned;

        // 3. ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        return "ã¾ã ãã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯å­¦ç¿’ã—ã¦ãªã„ã€‚ãŠå‰ãŒä¿®æ­£ã—ã¦ãã‚Œã‚Œã°æ¬¡ã‹ã‚‰ã¯è¦šãˆã‚‹ã€‚";
      }

      // å¤ã„memoryã‚’åœ§ç¸®ã—ã¦ archive ã«ç•³ã¿è¾¼ã‚€
      // maxKeep: è©³ç´°ãƒ­ã‚°ã¨ã—ã¦æ®‹ã™æœ€å¤§ä»¶æ•°
      compress(maxKeep = 500) {
        if (this.memory.length <= maxKeep) return; // ã¾ã åœ§ç¸®ä¸è¦

        const excess = this.memory.length - maxKeep;
        const old = this.memory.slice(0, excess);
        const keep = this.memory.slice(excess);

        for (const m of old) {
          const tokensUser = this.tokenize(m.user);
          const tokensBot  = this.tokenize(m.bot);
          const tokens = tokensUser.concat(tokensBot);
          for (const tok of tokens) {
            this.archive.tokenFreq[tok] = (this.archive.tokenFreq[tok] || 0) + 1;
          }
          this.archive.totalUtterances += 1;
        }

        this.memory = keep;
        this.save();
      }

      // localStorage ã«ä¿å­˜
      save() {
        const data = {
          memory: this.memory,
          archive: this.archive,
          nextId: this.nextId
        };
        try {
          localStorage.setItem("my_ai_brain", JSON.stringify(data));
        } catch (e) {
          console.error("ä¿å­˜ã‚¨ãƒ©ãƒ¼ï¼š", e);
        }
      }

      // localStorage ã‹ã‚‰èª­ã¿è¾¼ã¿
      load() {
        const raw = localStorage.getItem("my_ai_brain");
        if (!raw) return;
        try {
          const data = JSON.parse(raw);
          this.memory = data.memory || [];
          this.archive = data.archive || { tokenFreq: {}, totalUtterances: 0 };
          this.nextId = data.nextId || 1;
        } catch (e) {
          console.error("ãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ï¼š", e);
        }
      }
    }

    // ===== UIé€£æº =====
    const brain = new Brain();
    brain.load();

    const userInput = document.getElementById("userInput");
    const chatLog = document.getElementById("chatLog");
    const correctionInput = document.getElementById("correctionInput");
    const statsDiv = document.getElementById("stats");

    let lastMessageId = null;

    function appendLog(html) {
      chatLog.innerHTML += html + "\n";
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    function updateStats() {
      const mem = brain.memory.length;
      const totalUtterances = brain.archive.totalUtterances;
      const vocabSize = Object.keys(brain.archive.tokenFreq).length;
      statsDiv.textContent =
        `è©³ç´°ãƒ­ã‚°: ${mem} ä»¶ / åœ§ç¸®æ¸ˆã¿ç™ºè©±: ${totalUtterances} / åœ§ç¸®å´èªå½™æ•°: ${vocabSize}`;
    }

    updateStats();

    document.getElementById("sendBtn").addEventListener("click", () => {
      const text = userInput.value.trim();
      if (!text) return;

      const botText = brain.reply(text);
      const id = brain.learn(text, botText);
      lastMessageId = id;

      appendLog(`ğŸ§‘ <span class="msg-user">${escapeHtml(text)}</span>`);
      appendLog(`ğŸ¤– <span class="msg-bot">${escapeHtml(botText)}</span>`);

      userInput.value = "";
      updateStats();
    });

    document.getElementById("applyCorrectionBtn").addEventListener("click", () => {
      const corrected = correctionInput.value.trim();
      if (!corrected || lastMessageId == null) return;

      brain.learnCorrection(lastMessageId, corrected);

      appendLog(`âœï¸ <span class="msg-note">ç›´å‰ã®Botè¿”ç­”ã‚’ä¿®æ­£å­¦ç¿’: ${escapeHtml(corrected)}</span>`);
      correctionInput.value = "";
      updateStats();
    });

    document.getElementById("compressBtn").addEventListener("click", () => {
      brain.compress(500); // æœ€æ–°500ä»¶ã ã‘è©³ç´°ãƒ­ã‚°ã¨ã—ã¦æ®‹ã™
      updateStats();
      alert("å¤ã„ä¼šè©±ã‚’åœ§ç¸®ã—ã¦çµ±è¨ˆã«ç•³ã¿è¾¼ã‚“ã ã€‚é»’æ­´å²ã®ä¸€éƒ¨ãŒãƒ­ã‚°ã‹ã‚‰æ¶ˆãˆãŸãŒã€èªå½™ã¨ã—ã¦ã¯ç”Ÿãæ®‹ã£ã¦ã„ã‚‹ã€‚");
    });

    // ã‚·ãƒ³ãƒ—ãƒ«ãªXSSå¯¾ç­–ç”¨ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    function escapeHtml(str) {
      return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
  </script>
</body>
</html>
